<?php

declare(strict_types=1);

namespace App\Service\Common\DomainObjectGenerator;

use App\DomainObjects\AbstractDomainObject;
use App\Exceptions\NoDefaultValueAvailableForGeneratedDoProperty;
use Doctrine\DBAL\Schema\AbstractSchemaManager;
use Doctrine\DBAL\Schema\Column;
use Doctrine\DBAL\Schema\Table;
use Doctrine\DBAL\Types\Type;
use Illuminate\Foundation\Application;
use Illuminate\Support\Pluralizer;
use Illuminate\Support\Str;

class Generator
{
    private AbstractSchemaManager $schemaManager;

    private string $defaultNamespace = 'App\DomainObjects\Generated';

    private string $defaultModelPath = "DomainObjects/Generated";

    private string $defaultExtends = AbstractDomainObject::class;

    private array $defaultIgnoreProperties = [];

    private array $ignoredTables = [
        'migrations'
    ];

    private Application $app;

    public function __construct(Application $app, AbstractSchemaManager $schemaManager)
    {
        $this->schemaManager = $schemaManager;
        $this->app = $app;
    }

    /**
     * @return void
     * @throws NoDefaultValueAvailableForGeneratedDoProperty
     */
    public function run(): void
    {
        foreach ($this->schemaManager->listTables() as $table) {
            if (in_array($table->getName(), $this->ignoredTables, true)) {
                continue;
            }
            $modelTemplate = $this->getObjectHead($table->getName());
            $modelTemplate .= $this->getConstants($table);
            $modelTemplate .= $this->getProperties($table);
            $modelTemplate .= $this->getPublicMethods($table);
            $modelTemplate .= $this->getGettersSetters($table);
            $modelTemplate .= $this->getClosingBrace();

            $this->writeModel($table, $modelTemplate);
        }
    }

    /**
     * @param string $table
     * @return string
     */
    private function getObjectHead(string $table): string
    {
        $model = ucfirst(Str::camel(Pluralizer::singular($table))) . 'DomainObject';

        return "<?php

declare(strict_types=1);

namespace {$this->defaultNamespace};

/**
 * THIS FILE IS AUTOGENERATED - DO NOT EDIT IT DIRECTLY.
 *
 * Class {$model}
 * @package {$this->defaultNamespace}
 */
abstract class {$model} extends \\{$this->defaultExtends}
{";
    }

    /**
     * @param Table $table
     * @return string
     */
    private function getConstants(Table $table): string
    {
        $singularName = Str::singular($table->getName());
        $pluralName = Str::plural($singularName);

        $response = [];
        $response[] = "
    /** @var string */
    public const SINGULAR_NAME = '{$singularName}';

    /** @var string */
    public const PLURAL_NAME = '{$pluralName}';
";

        foreach ($table->getColumns() as $column) {
            if ($this->shouldIgnoreProperty($column->getName())) {
                continue;
            }

            $constName = Str::upper($column->getName());
            $response[] = "
    /** @var string */
    public const $constName = '{$column->getName()}';
";
        }

        return implode("", $response);
    }

    /**
     * @param string $property
     * @return bool
     */
    private function shouldIgnoreProperty(string $property): bool
    {
        return in_array($property, $this->defaultIgnoreProperties);
    }

    /**
     * @param Table $table
     * @return string
     * @throws NoDefaultValueAvailableForGeneratedDoProperty
     */
    private function getProperties(Table $table): string
    {
        $response = [];
        foreach ($table->getColumns() as $column) {
            if ($this->shouldIgnoreProperty($column->getName())) {
                continue;
            }

            $nullable = $column->getNotnull() ? '' : '?';

            $response[] = "
    /** @var {$this->getType($column->getType())} */
    protected {$nullable}{$this->getType($column->getType())} \${$column->getName()}{$this->getDefaultValue($column)};
";
        }

        return implode("", $response);
    }

    /**
     * @param Type $type
     * @return string|null
     */
    private function getType(Type $type): ?string
    {
        $type = match (strtolower($type->getName())) {
            Type::INTEGER, Type::BIGINT, Type::SMALLINT => 'int',
            Type::BOOLEAN => 'bool',
            Type::DECIMAL, Type::FLOAT => 'float',
            default => 'string',
        };

        return $type;
    }

    /**
     * @param Column $column
     * @return string
     * @throws NoDefaultValueAvailableForGeneratedDoProperty
     */
    private function getDefaultValue(Column $column): string
    {
        if (is_null($column->getDefault())) {
            return $column->getNotnull() ? '' : ' = null';
        }

        switch ($column->getType()->getName()) {
            case Type::STRING:
            case Type::TEXT:
            case Type::DATE:
            case Type::TIME:
            case Type::DATETIMETZ:
            case Type::DATETIME:
                return " = '{$column->getDefault()}'";
            case Type::INTEGER:
            case Type::BIGINT:
            case Type::SMALLINT:
            case Type::FLOAT:
            case Type::DECIMAL:
                return " = {$column->getDefault()}";
            case Type::GUID:
                return '';
            case Type::BOOLEAN:
                return " = " . ($column->getDefault() ? 'true' : 'false');
            default:
                throw new NoDefaultValueAvailableForGeneratedDoProperty(
                    sprintf('Unable to handle %s', $column->getType()->getName())
                );
        }
    }

    /**
     * @param Table $table
     * @return string
     */
    private function getPublicMethods(Table $table): string
    {
        $response[] = "
   /**
    * @return array
    */
    public function toArray(): array
    {
        return [";
        foreach ($table->getColumns() as $column) {
            if ($this->shouldIgnoreProperty($column->getName())) {
                continue;
            }

            $response[] = "
            '{$column->getName()}' => \$this->{$column->getName()} ?? null,";
        }
        $response[] = "
        ];
    }
    ";

        return implode("", $response);
    }

    /**
     * @param Table $table
     * @return string
     */
    private function getGettersSetters(Table $table)
    {
        $response = [];
        $first = true;
        foreach ($table->getColumns() as $column) {
            if ($this->shouldIgnoreProperty($column->getName())) {
                continue;
            }

            $nullable = $column->getNotnull() ? '' : '?';
            $nullableDocBlock = $column->getNotnull() ? '' : '|null';
            $model = ucfirst(Str::camel($column->getName()));
            $setterName = "set" . $model;
            $getterName = "get" . $model;

            $response[] = (!$first ? PHP_EOL : '') . "
   /**
    * @param {$this->getType($column->getType())} \${$column->getName()}
    * @return self
    */
    public function {$setterName}({$nullable}{$this->getType($column->getType())} \${$column->getName()}): self
    {
        \$this->{$column->getName()} = \${$column->getName()};

        return \$this;
    }

   /**
    * @return {$this->getType($column->getType())}{$nullableDocBlock}
    */
    public function {$getterName}(): {$nullable}{$this->getType($column->getType())}
    {
        return \$this->{$column->getName()};
    }";
            $first = false;
        }

        return implode("", $response);
    }

    /**
     * @return string
     */
    private function getClosingBrace(): string
    {
        return PHP_EOL . '}';
    }

    /**
     * @param Table $table
     * @param string $modelContent
     */
    private function writeModel(Table $table, string $modelContent)
    {
        $path = $this->app->path($this->defaultModelPath);
        $model = Pluralizer::singular(ucfirst(Str::camel($table->getName()))) . 'DomainObject';
        $file = $path . '/' . $model . '.php';

        if (file_exists($file)) {
            unlink($file);
        }

        file_put_contents($file, $modelContent);
    }
}
